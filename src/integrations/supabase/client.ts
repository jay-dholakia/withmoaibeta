
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';
import { debounce, isRetriableNetworkError } from '@/lib/utils';

const SUPABASE_URL = "https://gjrheltyxjilxcphbzdj.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImdqcmhlbHR5eGppbHhjcGhiemRqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDI1MDkyNzcsImV4cCI6MjA1ODA4NTI3N30.T1dnULbKmLGr7PsEvONlnQeuSEPz19706325o-3HD18";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
  auth: {
    persistSession: true,
    autoRefreshToken: true,
    storageKey: 'supabase.auth.token',
    storage: localStorage,
    detectSessionInUrl: false, // Prevents potential redirect loops
    flowType: 'pkce' // More secure flow type
  },
  realtime: {
    params: {
      eventsPerSecond: 2 // Limit events per second for realtime subscribers
    }
  },
  global: {
    // Add better retry logic for network requests
    headers: {
      'X-Client-Info': 'lovable-app/1.0.0'
    },
    fetch: (url, options) => {
      // Custom fetch with timeout and retry logic
      const timeoutPromise = new Promise((_, reject) => {
        setTimeout(() => reject(new Error('Request timeout')), 30000); // Extended timeout to 30 seconds
      });
      
      const fetchWithRetries = async () => {
        let lastError;
        
        for (let attempt = 0; attempt < 5; attempt++) { // Increased max retries
          try {
            // Add small delay between retries, but not on first attempt
            if (attempt > 0) {
              await new Promise(resolve => setTimeout(resolve, Math.min(attempt * 1000, 3000)));
            }
            
            const response = await fetch(url, options);
            
            // Log detailed info about failing responses
            if (!response.ok) {
              console.warn(`Supabase request failed (attempt ${attempt+1}/5):`, {
                url,
                status: response.status,
                statusText: response.statusText
              });
              
              // For certain status codes, we should not retry
              if (response.status === 404 || 
                  response.status === 401 || 
                  response.status === 403) {
                return response;
              }
              
              // For server errors with 5xx, retry again
              if (response.status >= 500) {
                throw new Error(`Server error: ${response.status}`);
              }
            }
            
            return response;
          } catch (error: any) {
            lastError = error;
            console.warn(`Supabase request error (attempt ${attempt+1}/5):`, error?.message);
            
            // Only retry on network errors and server errors
            if (!isRetriableNetworkError(error) && !error.message?.includes('Server error')) {
              throw error;
            }
          }
        }
        
        // If we've exhausted all retries, throw the last error
        throw lastError;
      };
      
      return Promise.race([
        fetchWithRetries(),
        timeoutPromise
      ]) as Promise<Response>;
    }
  }
});

// Create a utility to help with managing subscriptions
export class SubscriptionManager {
  private static subscriptions: Map<string, { channel: any, count: number }> = new Map();
  
  // Get or create a subscription with reference counting
  static getSubscription(channelName: string, factory: () => any): any {
    const existing = this.subscriptions.get(channelName);
    
    if (existing) {
      existing.count++;
      return existing.channel;
    }
    
    const channel = factory();
    this.subscriptions.set(channelName, { channel, count: 1 });
    return channel;
  }
  
  // Release a subscription, removing if no more references
  static releaseSubscription(channelName: string): void {
    const existing = this.subscriptions.get(channelName);
    if (!existing) return;
    
    existing.count--;
    
    if (existing.count <= 0) {
      supabase.removeChannel(existing.channel);
      this.subscriptions.delete(channelName);
      console.log(`Released subscription: ${channelName}`);
    }
  }
  
  // Add a method to check active subscriptions (useful for debugging)
  static getActiveSubscriptions(): string[] {
    return Array.from(this.subscriptions.keys());
  }
}
